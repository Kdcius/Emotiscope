// -----------------------------------------------------------------------------------------
//              _                                 _                                  _
//             (_)                               | |                                | |
//  _ __ ___    _    ___   _ __    ___    _ __   | |__     ___    _ __     ___      | |__
// | '_ ` _ \  | |  / __| | '__|  / _ \  | '_ \  | '_ \   / _ \  | '_ \   / _ \     | '_ \ 
// | | | | | | | | | (__  | |    | (_) | | |_) | | | | | | (_) | | | | | |  __/  _  | | | |
// |_| |_| |_| |_|  \___| |_|     \___/  | .__/  |_| |_|  \___/  |_| |_|  \___| (_) |_| |_|
//                                       | |
//                                       |_|
//
// Functions for reading and storing data acquired by the I2S microphone0

#include "driver/i2s_std.h"
#include "driver/gpio.h"

// Define I2S pins
#define I2S_BCLK_PIN 6
#define I2S_LRCLK_PIN 5
#define I2S_DIN_PIN 4

#define CHUNK_SIZE 64
#define SAMPLE_RATE 12800

#define SAMPLE_HISTORY_LENGTH 4096

float sample_history[SAMPLE_HISTORY_LENGTH];
const float recip_scale = 1.0 / 80000000.0;

volatile bool waveform_locked = false;
volatile bool waveform_sync_flag = false;

i2s_chan_handle_t rx_handle;

// TODO: Update I2S microhpone driver to IDF 5.x version
void init_i2s_microphone(){
	/* Get the default channel configuration by helper macro.
	* This helper macro is defined in `i2s_common.h` and shared by all the I2S communication modes.
	* It can help to specify the I2S role and port ID */
	i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
	/* Allocate a new RX channel and get the handle of this channel */
	i2s_new_channel(&chan_cfg, NULL, &rx_handle);

	/* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
	* These two helper macros are defined in `i2s_std.h` which can only be used in STD mode.
	* They can help to specify the slot and clock configurations for initialization or updating */
	i2s_std_config_t std_cfg = {
		.clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(12800),
		.slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_MONO),
		.gpio_cfg = {
			.mclk = I2S_GPIO_UNUSED,
			.bclk = (gpio_num_t)I2S_BCLK_PIN,
			.ws = (gpio_num_t)I2S_LRCLK_PIN,
			.dout = I2S_GPIO_UNUSED,
			.din = (gpio_num_t)I2S_DIN_PIN,
			.invert_flags = {
				.mclk_inv = false,
				.bclk_inv = false,
				.ws_inv = false,
			},
		},
	};
	/* Initialize the channel */
	i2s_channel_init_std_mode(rx_handle, &std_cfg);

	/* Before reading data, start the RX channel first */
	i2s_channel_enable(rx_handle);
}

void acquire_sample_chunk() {
	profile_function([&]() {
		// Buffer to hold audio samples
		int32_t new_samples_raw[CHUNK_SIZE];
		float new_samples_raw_float[CHUNK_SIZE];
		float new_samples[CHUNK_SIZE];

		// Read audio samples into int32_t buffer
		size_t bytes_read = 0;
		//i2s_read(I2S_NUM_0, new_samples_raw, sizeof(new_samples_raw), &bytes_read, portMAX_DELAY);
		i2s_channel_read(rx_handle, new_samples_raw, sizeof(new_samples_raw), &bytes_read, 10);

		// Clip the sample value if it's too large, cast to large floats
		for (uint16_t i = 0; i < CHUNK_SIZE; i+=4) {
			new_samples_raw_float[i+0] = min(max((int32_t)new_samples_raw[i+0], (int32_t)-80000000), (int32_t)80000000);
			new_samples_raw_float[i+1] = min(max((int32_t)new_samples_raw[i+1], (int32_t)-80000000), (int32_t)80000000);
			new_samples_raw_float[i+2] = min(max((int32_t)new_samples_raw[i+2], (int32_t)-80000000), (int32_t)80000000);
			new_samples_raw_float[i+3] = min(max((int32_t)new_samples_raw[i+3], (int32_t)-80000000), (int32_t)80000000);
		}

		// Convert audio from large float range to -1.0 to 1.0 range
		dsps_mulc_f32(new_samples_raw_float, new_samples, CHUNK_SIZE, recip_scale, 1, 1);

		// Add new chunk to audio history
		waveform_locked = true;
		shift_and_copy_arrays(sample_history, SAMPLE_HISTORY_LENGTH, new_samples, CHUNK_SIZE);
		waveform_locked = false;
		waveform_sync_flag = true;

		/*
		// Used to print raw microphone values over UART for debugging
		float* samples = &sample_history[SAMPLE_HISTORY_LENGTH-1-CHUNK_SIZE];
		char output[32];
		memset(output, 0, 32);
		for(uint16_t i = 0; i < CHUNK_SIZE; i++){
			uint16_t offset = 16;
			uint16_t position = offset + int16_t(samples[i]*8.0);
			memset(output, 0, 32);
			memset(output, ' ', position);
			output[position] = '|';
			printf("%s\n", output);
		}
		*/

	}, __func__);
}
